# 微服务综述

### 一、前言

微服务架构12年兴起，14年传入中国，15年大厂开始做微服务架构改造，18年左右中小型企业也开始做微服务架构了。

传统企业：JAVAEE java企业级开发，针对企业内部的，就比如我们现在的项目

OA，CRM，ERP

互联网企业：电商 亿级并发 百万级并发

### 二、微服务架构

##### 1、JAVAEE的问题

JAVAEE：

三层架构：

视图层：controller

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块    

业务层：service

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块   

数据层：dao

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块   

存在的问题：如果一个模块出问题了，所有的模块都可能不可用。解决方法：将每个模块当做独立的服务部署起来

每个服务还是三层架构：

服务A：192.168.0.1

​	视图层：账单模块 controller

​	业务层：账单模块 service

​	数据层：账单模块 dao

服务B：192.168.0.2

​	视图层：用户模块 controller

​	业务层：用户模块 service

​	数据层：用户模块 dao

.....

这种情况下，可以避免A服务挂了之后影响B服务，这就是分布式系统。这个系统对于用户是不可见的。

##### 2、微服务的引入

**微服务架构是一种结构思想，架构是为了解耦。实际的开发方式是分布式系统开发。**

开发方式：spring boot + spring cloud

spring cloud 是一个编程模型，微服务开发的一种标准，一系列的接口，具体的实现有：

spring cloud netflix 网飞

spring cloud alibaba 阿里巴巴

微服务架构主要目标：

满足三大指标：

- 高可用：服务一直可以用，要满足N个9，也就是一年有N和9%的时间系统要可用。比如99.9999%，即一年允许宕机的时间为 365 x 24 x 60 x 60 x 0.00001% = 31s
- 高性能：能快点就快一点，响应速度尽可能快
- 高并发：系统的承载能力

解决四大问题：

- 客户端如何访问
- 服务与服务之间如何通信
- 服务如何治理
- 服务挂了怎么办

##### 3、如何应对高并发

有两种方式：

垂直扩展：

​			升级配置，1cpu2G   --> 4cpu128G，这种方式存在的问题是存在性能瓶颈，因为硬件性能是有上限的。

水平扩展：

​			多买服务器，买10个1cpu2G ，部署同一个模块；同时根据不同模块的系统类型使用不同的服务器

```
系统：

计算密集型，吃cpu

内存密集型，吃内存
```

##### 4、负载均衡

在多个服务器上部署同一个模块时，就引出了一个问题：负载均衡。我们知道Nginx可以解决负载均衡，springcloud也自带负载均衡解决方案。所以负载均衡的解决方案我们不需要考虑，但是**负载均衡策略**我们是需要考虑的。

负载均衡策略包括：轮询，hash一致性，权重。

当部署同一个模块的多个服务器的配置一样时，适合轮询；不一致时，适合权重；

当在不同地区架设服务器时，让用户根据位置的远近去访问不同的服务器，这时候适合hash一致，此时用户的请求通过**CDN网络分发机制**发送到不同的服务器。

同时这几种策略可以配合使用。

**领域驱动设计**

### 三、数据库应对高并发

##### 1、数据库扩展思路

针对传统的开发，所有的数据库都放到一个mysql里面，这种情况会有一个很大的弊端：**单点故障**（由一个节点引发全局故障，也叫**中心化**）：即如果数据库挂了，则所有的模块都会出问题。

**数据库的垂直扩展：每个库放到一个单独的mysql中。**

此时，还有另外一个问题：mysql是有性能瓶颈的，因为b+tree，因为io的检索次数，因为分页的16kb限制，因为索引的存储空间等，会导致单表数据不能超过2100w条。当超过这个数据时，性能会大大降低，违背高性能的要求。此时就要考虑水平扩展，打破单表2100w条数据的性能瓶颈。

具体做法：比如一个mysql中只有一个user库，则可以在这个库中放user_1,user_2....user_10，每个表可以放2000w数据，则整个库就可以放大量数据。同时可以再开启一个mysql，放一个user_1库，这个库里面也放10张表。

##### 2、扩展之后的数据库

目前mysql结构如下：

```
数据库

USER_0  192.168.0.1

​	数据表

​		user_0：其中有两个重要字段

​				ID：主键  唯一键  可以根据ID将数据分到不同的表（比如根据尾号决定放哪个表）：2020042623530000

​				bID：业务ID 唯一键（可以根据bID的尾号决定放哪个数据库）

​		user_1

​				ID：2020042623530001

​		...

​		user_9

​				ID：2020042623530009

USER_1  192.168.0.2

​	数据表

​		user_0

​		user_1

​		...

​		user_9

ORDER_0  192.168.0.3

​	数据表

​		order_0

​		order_1

​		...

​		order_9
```

#####  3、扩展之后写的问题

主从模式，即读写分离，分master和slave数据库，master负责写，slave负责读。向master数据库中写入数据，从slave数据库中读取数据，master数据库写入时需要向slave数据库同步。如果master数据库做了集群，则master数据库之间还需要同步，此时master数据库之间可能会产生主键冲突的问题。

如果master数据库只有两个，则可以设置不同的起始id，然后设置不同的步长，这种叫双活数据中心。

如果两个也不够的话，就必须使用唯一主键（分布式主键），这种叫做多活数据中心，如果master数据库还分布在不同的地理位置，则叫异地多活数据中心，此时主键的生成可以采用雪花算法。

**在不同的数据中心之间，可以采用雪花算法避免数据主键冲突。在一个具体的数据中心中，可以采用上面的分库分表来存储数据，同时根据主键来使数据落到不同的数据库中。**

##### 4、扩展之后读的问题

如何进行查询？

比如 `select * from user;`，传统情况下不用考虑这个问题，但是现在有多个数据库，每个数据库里面还可能有多个表，如何查询？此时需要配置多数据源。

```
逻辑查询
select * from user;
物理查询
select * from USER_0.user_0;
select * from USER_0.user_1;
....
select * from USER_0.user_9;
select * from USER_1.user_0;
....
select * from USER_1.user_9;
```

但是在写代码时不可能这样写的。解决方法：**分布式数据库中间件**

在写代码的时候使用逻辑查询，然后将这个sql发送给专门处理数据库的微服务，即分布式数据库中间件，在这个微服务里面将这个逻辑查询转换为物理查询，进而进行后续操作。



分布式数据库中间件服务  -->  高内聚、低耦合（一个类只做一种事，一个防范只做一件事；一个服务只做一类事），这个服务需要做：

解析sql，配置多数据源，分库分表规则（分片）

这个微服务也可以用springboot搭建，在其yml文件中，起码需要以下两部分：物理配置、逻辑配置

```
物理配置
db_0
	url:mysql1:port
	username:root
	password:123456
	pool:
db_1
	url:mysql2:port
	username:root
	password:123456
	pool:
	dbname:user_${id % 10}  // 将数据库名转化为物理上的一堆数据库名
逻辑配置
table：
	user： user_${bid % 10}  // 将逻辑上的user表转化为物理上的user_系列表
```

配置完毕之后这个微服务就可以将逻辑查询转化为物理查询了。

这种解决方案就是非侵入式。



分布式事务中间件有两大选型方案：MyCat、Sharding-Sphere，建议使用后者，因为前者在遇到大规模并发的时候可能会遇到一些无法解决的问题。同时前者是重启了阿里淘汰的一个分库分表框架，民间组织管理；后者是当当捐献给apach的一个开源项目。

Sharding-Sphere有三大组件：

sharding-jdbc：在源码里依赖，有一定的侵入性

sharding-proxy：分布式数据库中间件，单独部署

sharding-sidecar：放在kubernets里，高可用，还在孵化中
##### 5、数据库拆分综述
https://zhuanlan.zhihu.com/p/50662103
当遇到数据库性能瓶颈的时候，可以按照以下步骤进行处理：
1、使用缓存，降低对数据库的读操作
2、如果使用了缓存之后，数据库访问量还是很大，则可以考虑数据库读、写分离原则
3、在2的情况下，如果还是不能满足需求，则可以考虑数据库拆分了
4、首选垂直拆分，也就是将不同的表分布到不同的数据库上面
5、其次可以考虑水平拆分，也就是分库分表。垂直拆分是把不同的表拆分到不同的数据库中，水平拆分则是把同一张表拆分到不同的数据库中


### 四、CAP理论

C：一致性，强一致性

一致性分类：

- 强一致性
- 弱一致性
  - 顺序一致性
  - 最终一致性

A：可用性 --> 高可用，高性能

P：分区容错性

分布式系统需要保证分区容错性，所以只剩下cp和ap的选项。

CP： 强一致性系统  ->金融系统

AP： 高可用性系统  -> 互联网

```
两地三活：即有一个备用机房专门用来备份其他机房的数据，为了防止备用机房在挂掉的情况下，人们并没有意识到，所以也会让备用机房承载一部分的并发，这样如果备用机房挂掉的话则可以立马知晓。
```

因为强一致性对性能的打击很大，而又需要考虑高性能，所以可以考虑弱一致性，所以就有了BASE理论，就要讲了数据一致性的问题。

BASE理论：

BA：基本可用

S：软状态

E：最终一致性 		

如何保证最终一致性？RAFT协议









