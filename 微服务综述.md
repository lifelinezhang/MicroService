# 微服务综述

### 一、前言

微服务架构12年兴起，14年传入中国，15年大厂开始做微服务架构改造，18年左右中小型企业也开始做微服务架构了。

传统企业：JAVAEE java企业级开发，针对企业内部的，就比如我们现在的项目

OA，CRM，ERP

互联网企业：电商 亿级并发 百万级并发

### 二、微服务架构

##### 1、JAVAEE的问题

JAVAEE：

三层架构：

视图层：controller

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块    

业务层：service

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块   

数据层：dao

​		账单模块

​		用户模块

​		支付模块

​		登录模块

​		注册模块   

存在的问题：如果一个模块出问题了，所有的模块都可能不可用。解决方法：将每个模块当做独立的服务部署起来

每个服务还是三层架构：

服务A：192.168.0.1

​	视图层：账单模块 controller

​	业务层：账单模块 service

​	数据层：账单模块 dao

服务B：192.168.0.2

​	视图层：用户模块 controller

​	业务层：用户模块 service

​	数据层：用户模块 dao

.....

这种情况下，可以避免A服务挂了之后影响B服务，这就是分布式系统。这个系统对于用户是不可见的。

##### 2、微服务的引入

**微服务架构是一种结构思想，架构是为了解耦。实际的开发方式是分布式系统开发。**

开发方式：spring boot + spring cloud

spring cloud 是一个编程模型，微服务开发的一种标准，一系列的接口，具体的实现有：

spring cloud netflix 网飞

spring cloud alibaba 阿里巴巴

微服务架构主要目标：

满足三大指标：

- 高可用：服务一直可以用，要满足N个9，也就是一年有N和9%的时间系统要可用。比如99.9999%，即一年允许宕机的时间为 365 x 24 x 60 x 60 x 0.00001% = 31s
- 高性能：能快点就快一点，响应速度尽可能快
- 高并发：系统的承载能力

解决四大问题：

- 客户端如何访问
- 服务与服务之间如何通信
- 服务如何治理
- 服务挂了怎么办

##### 3、如何应对高并发

有两种方式：

垂直扩展：

​			升级配置，1cpu2G   --> 4cpu128G，这种方式存在的问题是存在性能瓶颈，因为硬件性能是有上限的。

水平扩展：

​			多买服务器，买10个1cpu2G ，部署同一个模块；同时根据不同模块的系统类型使用不同的服务器

```
系统：

计算密集型，吃cpu

内存密集型，吃内存
```

##### 4、负载均衡

在多个服务器上部署同一个模块时，就引出了一个问题：负载均衡。我们知道Nginx可以解决负载均衡，springcloud也自带负载均衡解决方案。所以负载均衡的解决方案我们不需要考虑，但是**负载均衡策略**我们是需要考虑的。

负载均衡策略包括：轮询，hash一致性，权重。

当部署同一个模块的多个服务器的配置一样时，适合轮询；不一致时，适合权重；

当在不同地区架设服务器时，让用户根据位置的远近去访问不同的服务器，这时候适合hash一致，此时用户的请求通过**CDN网络分发机制**发送到不同的服务器。

同时这几种策略可以配合使用。

**领域驱动设计**

### 三、数据库应对高并发

##### 1、数据库扩展思路

针对传统的开发，所有的数据库都放到一个mysql里面，这种情况会有一个很大的弊端：**单点故障**（由一个节点引发全局故障，也叫**中心化**）：即如果数据库挂了，则所有的模块都会出问题。

**数据库的垂直扩展：每个库放到一个单独的mysql中。**

此时，还有另外一个问题：mysql是有性能瓶颈的，因为b+tree，因为io的检索次数，因为分页的16kb限制，因为索引的存储空间等，会导致单表数据不能超过2100w条。当超过这个数据时，性能会大大降低，违背高性能的要求。此时就要考虑水平扩展，打破单表2100w条数据的性能瓶颈。

具体做法：比如一个mysql中只有一个user库，则可以在这个库中放user_1,user_2....user_10，每个表可以放2000w数据，则整个库就可以放大量数据。同时可以再开启一个mysql，放一个user_1库，这个库里面也放10张表。

##### 2、扩展之后的数据库

目前mysql结构如下：

```
数据库

USER_0  192.168.0.1

​	数据表

​		user_0：其中有两个重要字段

​				ID：主键  唯一键  可以根据ID将数据分到不同的表（比如根据尾号决定放哪个表）：2020042623530000

​				bID：业务ID 唯一键（可以根据bID的尾号决定放哪个数据库）

​		user_1

​				ID：2020042623530001

​		...

​		user_9

​				ID：2020042623530009

USER_1  192.168.0.2

​	数据表

​		user_0

​		user_1

​		...

​		user_9

ORDER_0  192.168.0.3

​	数据表

​		order_0

​		order_1

​		...

​		order_9
```

#####  3、扩展之后写的问题

主从模式，即读写分离，分master和slave数据库，master负责写，slave负责读。向master数据库中写入数据，从slave数据库中读取数据，master数据库写入时需要向slave数据库同步。如果master数据库做了集群，则master数据库之间还需要同步，此时master数据库之间可能会产生主键冲突的问题。

如果master数据库只有两个，则可以设置不同的起始id，然后设置不同的步长，这种叫双活数据中心。

如果两个也不够的话，就必须使用唯一主键（分布式主键），这种叫做多活数据中心，如果master数据库还分布在不同的地理位置，则叫异地多活数据中心，此时主键的生成可以采用雪花算法。

**在不同的数据中心之间，可以采用雪花算法避免数据主键冲突。在一个具体的数据中心中，可以采用上面的分库分表来存储数据，同时根据主键来使数据落到不同的数据库中。**

##### 4、扩展之后读的问题

如何进行查询？

比如 `select * from user;`，传统情况下不用考虑这个问题，但是现在有多个数据库，每个数据库里面还可能有多个表，如何查询？此时需要配置多数据源。

```
逻辑查询
select * from user;
物理查询
select * from USER_0.user_0;
select * from USER_0.user_1;
....
select * from USER_0.user_9;
select * from USER_1.user_0;
....
select * from USER_1.user_9;
```

但是在写代码时不可能这样写的。解决方法：**分布式数据库中间件**

在写代码的时候使用逻辑查询，然后将这个sql发送给专门处理数据库的微服务，即分布式数据库中间件，在这个微服务里面将这个逻辑查询转换为物理查询，进而进行后续操作。



分布式数据库中间件服务  -->  高内聚、低耦合（一个类只做一种事，一个防范只做一件事；一个服务只做一类事），这个服务需要做：

解析sql，配置多数据源，分库分表规则（分片）

这个微服务也可以用springboot搭建，在其yml文件中，起码需要以下两部分：物理配置、逻辑配置

```
物理配置
db_0
	url:mysql1:port
	username:root
	password:123456
	pool:
db_1
	url:mysql2:port
	username:root
	password:123456
	pool:
	dbname:user_${id % 10}  // 将数据库名转化为物理上的一堆数据库名
逻辑配置
table：
	user： user_${bid % 10}  // 将逻辑上的user表转化为物理上的user_系列表
```

配置完毕之后这个微服务就可以将逻辑查询转化为物理查询了。

这种解决方案就是非侵入式。



分布式事务中间件有两大选型方案：MyCat、Sharding-Sphere，建议使用后者，因为前者在遇到大规模并发的时候可能会遇到一些无法解决的问题。同时前者是重启了阿里淘汰的一个分库分表框架，民间组织管理；后者是当当捐献给apach的一个开源项目。

Sharding-Sphere有三大组件：

sharding-jdbc：在源码里依赖，有一定的侵入性

sharding-proxy：分布式数据库中间件，单独部署

sharding-sidecar：放在kubernets里，高可用，还在孵化中
##### 5、数据库拆分综述
https://zhuanlan.zhihu.com/p/50662103
当遇到数据库性能瓶颈的时候，可以按照以下步骤进行处理：
1、使用缓存，降低对数据库的读操作
2、如果使用了缓存之后，数据库访问量还是很大，则可以考虑数据库读、写分离原则
3、在2的情况下，如果还是不能满足需求，则可以考虑数据库拆分了
4、首选垂直拆分，也就是将不同的表分布到不同的数据库上面
5、其次可以考虑水平拆分，也就是分库分表。垂直拆分是把不同的表拆分到不同的数据库中，水平拆分则是把同一张表拆分到不同的数据库中


### 四、CAP理论

C：一致性，强一致性

一致性分类：

- 强一致性
- 弱一致性
  - 顺序一致性
  - 最终一致性

A：可用性 --> 高可用，高性能

P：分区容错性

分布式系统需要保证分区容错性，所以只剩下cp和ap的选项。

CP： 强一致性系统  ->金融系统

AP： 高可用性系统  -> 互联网

```
两地三活：即有一个备用机房专门用来备份其他机房的数据，为了防止备用机房在挂掉的情况下，人们并没有意识到，所以也会让备用机房承载一部分的并发，这样如果备用机房挂掉的话则可以立马知晓。
```

因为强一致性对性能的打击很大，而又需要考虑高性能，所以可以考虑弱一致性，所以就有了BASE理论，就要讲了数据一致性的问题。

BASE理论：

BA：基本可用

S：软状态

E：最终一致性 		

如何保证最终一致性？RAFT协议

### 五、微服务架构设计模式

额外做个了解



### 六、客户端如何访问

在最原始的情况下，客户端进行访问的时候，如果直接根据微服务的ip地址去进行访问，则这么多ip，会难以维护。

解决方案：**网关**

方案选型：

zuul：网飞的，是同步并阻塞的

spring cloud gateway：是基于webflux的，是异步的，效率会比zuul高

openRestry： 物联网用的

kong

在使用网关的情况下，网关是如何知道有哪些微服务以及哪些微服务可用呢？

难道也把所有的微服务地址配置到网关中吗？肯定不可行，耦合性太高。

同时如果网关在不知情的情况下将一个请求发送给了一个挂了的微服务，依旧会造成阻塞问题。

此时的解决办法：**注册中心**

### 七、注册中心

consoule，euraka，nacos

当所有服务启动之后，先去注册到注册中心。

所有相同功能的微服务集群使用同一个微服务名。

当用户请求到达网关的时候，网关去注册中心根据微服务名寻找相应的微服务，并且把该微服务名下面的所有ip同步至网关，从而进一步实现负载均衡。

注册中心里面实现观察者模式，用来进行健康监测，判断微服务是够挂掉。如果挂了，则删除对应的ip，并异步通知网关，删除网关中对应的挂掉的ip，这样就能避免阻塞。

-----

链路追踪（zipkin、skywalking）、日志收集（elk）：查看服务时因为什么原因挂掉，从而之后避免这种情况

____

zookeeper： 分布式协调技术  分布式锁

不是专门的注册中心技术，但是能拿来做注册中心的原因是里面 有一个znode，支持有序节点（不建议使用zookeeper做注册中心）

### 八、服务之间通信

有两种方式：

1、同步调用：http、rpc：**对外REST，对内RPC：在同一个局域网之中使用RPC，不在局域网中则使用HTTP（REST）**

2、异步调用：消息队列（rocketmq、rabbitmq）

##### 1、http

实现方式是@FeignClient（“服务名”） 

##### 2、RPC

如果是使用的dubbo，则有@Reference（“服务名”）

### 九、服务挂了怎么办

熔断机制（Netflix ：hystrix；  阿里巴巴： sentital）

负载均衡？

### 十、微服务架构设计模式（MSA）

##### 1、优点

- 降低成本（容器化技术，docker ）

  每个服务运行在docker的容器上面，避免因为一个服务的死循环造成整台电脑的cpu爆炸

- 提高交付速度：持续集成

- 增强健壮性：也是docker的优点

- 提供可视化支持

##### 2、微服务架构的设计原则

- 伸缩能力（使用k8s自动复制或减少docker里面的容器，实现自动扩缩容）
- 可用性（崩溃恢复，即自动重启，k8s可以实现容器的自动重启）
- 健壮性
- 弹性（k8s）
- 独立的匿名服务
- 去中心化的治理（服务治理，k8s+istio）
- 故障隔离（容器之间的隔离机制）
- 自动供给（k8s）
- 通过devops实现持续交付（gitlab  jenkins）












































